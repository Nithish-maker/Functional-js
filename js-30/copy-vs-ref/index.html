<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <title>Copy vs Reference</title>
  </head>
  <body>
  	<script type="text/javascript">
  	// TODO		
  	/* *

	1. Checking out the values of distinct variables by copying each other 
	2. Checking out for every primitive types with some basic assignment and arithmetic operation
	3. Working with non-primitives 
	4. Ways to fix issues in terms of non-primitives (reference copies) to normal individual copies
	* */

	/* Primitives
	   | --int
	   | --float(precised)
	   | --string
	   | --boolean
	   | --null and undefined
	*/
	// int
	let num1 = 34;
	let num2 = num1;
	num2 = num1 + 20;
	let num3;
	num3 = num2;
	num3  = num2 +  num1;

	// precised float 
	let fNum = 34.562143;
	let newFnum = fNum;
	newFnum = fNum * parseFloat(newFnum);
	//console.log(num1, num2, num3, fNum.toFixed(2), newFnum.toFixed(3));

	// string
	let fName = "Nithish";
	let lName = "Raina";
	let mName = lName.split('').slice(0,1).join('').toUpperCase();
	mName = lName;
	mName = mName + "03";
	//console.log(`${fName} ${lName} ${mName}`);

	// bool
	let isAuthorized = true;
	let notAuthorized = isAuthorized;
	alert('Trying to access unAllowed endpoint');
	notAuthorized = !(isAuthorized);
	function authOrNot() {
	  return isAuthorized ? isAuthorized : notAuthorized;
	}
	authOrNot();
	// console.log(isAuthorized, notAuthorized);

	//Null and undefined 
	let val = null;
	let newVal;   //binded to the value undefined in the execution context
	newVal = val; //Comment out to check for the difference
	typeof(val) == typeof(newVal) ? "Identical": "Distinct";
	NaN === NaN ? "YES" : "NO";
	NaN === null ? "YES" : "NO";
	NaN === undefined ? "YES" : "NO";
	null === null ? "YES" : "NO";
	undefined === null ? "YES" : "NO";

	/* Arrays and objects  */
	// Arrays

	const likes = ['233','455','33'];
	const personLikes = likes;
	personLikes[0] = '344';
	// console.table(likes);
	// console.table(personLikes);

	/* Ways to fix the above issue 
	1.(using newArray and concatenating the older array) */
	const likes = ['233','455','33'];
	const personLikes = [].concat(likes);
	personLikes[0] = '344';
	console.table(likes);
	console.table(personLikes);

	/* 2. Using spread operator */
	const likes = ['233','455','33'];
	const personLikes = [...likes];
	personLikes[0] = '344';
	console.table(likes);
	console.table(personLikes);

	// Objects
	const person = {
    	name: 'Wes Bos',
    	age: 80
	};
	const newPerson = person;
	person['name'] = "nithish";
	console.table(person);
	console.table(newPerson);

	/* Fixing the issue */
	// 1. Using the object assign method

	const person = {
      name: 'Wes Bos',
      age: 80
	};
	const newPerson = Object.assign({},person,{name : "nithish", age : 20});
	newPerson['name'] = "nithish";
	console.table(person);
	console.table(newPerson);

	// 2. Using spread operator 
	const person = {
      name: 'Wes Bos',
      age: 80
	};
	const newPerson = {...person};
	newPerson['name'] = "nithish";
	console.table(person);
	console.table(newPerson);

	// 3. Using JSON Stringify to convert the older obj to an stringified objects and finally pasring it as a JSON object as a new Object
	const person = {
      name: 'Wes Bos',
      age: 80
	};
	const newPerson = JSON.parse(JSON.stringify(person));
	newPerson['name'] = "nithish";
	console.table(person);
	console.table(newPerson);	

	// NOTE : Here the object assign copies the array into a new object for the level 1 alone and inorder to go and get out a deep copy of the object deepClone has to be used
  	</script>
  </body>
</html>
